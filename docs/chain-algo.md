# Алгоритм оптимизации критического пути путем последовательных оптимизаций распределения исполнителей по задачам (не завершен)

## Обзор

Главная идея алгоритма заключается в последовательной оптимизации критического пути, где каждая новая микро-оптимизация приближает нас к лучшему результату, благодаря чему алгоритм становится более гибким для внедрений новых оптимизаций

### Первая оптимизация

Исполнителям назначаются темы (1 исполнитель - 1 тема) относительно их топа коэффициента оперативности

Пример топа исполнителей по темам относительно коэффициента оперативности

|       | Тема 1 | Тема 2 | Тема 3 | Тема 4 | Тема 5 | Тема 6 | Тема 7 | Тема 8 | Тема 9 |
|-------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
| **0** |    121 |    148 |    121 |    148 |    125 |    121 |    121 |    148 |    148 |
| **1** |    148 |    125 |    148 |     71 |    148 |    125 |    125 |    121 |    121 |
| **2** |     71 |     57 |     71 |     11 |     71 |     57 |    148 |    125 |    125 |
| **3** |    125 |    121 |     11 |     57 |    121 |     11 |     57 |     71 |     11 |
| **4** |     11 |     71 |    125 |    125 |     57 |    148 |     71 |     11 |     57 |
| **5** |     57 |     11 |     57 |    121 |     11 |     71 |     11 |     57 |     71 |

Исходя из топа оперативности, формируется путь каждого отдельного исполнителя по темам

| worker |   path  | duration |
|--------|---------|----------|
|     11 |         |        0 |
|     57 |         |        0 |
|     71 |         |        0 |
|    121 | .1.3.6.7|     2540 |
|    125 |     .5  |      375 |
|    148 | .2.4.8.9|     5400 |

### Вторая оптимизация

Следующая оптимизация берет прошлый результат и уменьшает критический путь на основе топа оперативности (так, если в первой оптимизации мы брали нулевой топ, здесь мы рассматриваем и следующие топы для уменьшения критического пути)

| worker |     path    | duration |
|--------|-------------|----------|
|     11 |             |        0 |
|     57 |         .6  |     1010 |
|     71 |       .3.1  |      285 |
|    121 |         .7  |     1245 |
|    125 | .5.2.8.9    |     2720 |
|    148 |         .4  |     3055 |

## Третья оптимизация (TODO)

Здесь предполагалось раскрытие тем в отдельные задачи для последующего переназначения их на нескольких исполнителей

Для этого требуется написать функцию, что рассчитывает время исполнения темы при учете 2 и более исполнителей

Далее проверяется, стало ли лучше время, и если да, применяется результат

Нужно учесть временной промежуток, т.к. время исполнения темы есть начало первой задачи и окончание последней (потенциально исполнители могут придти в разное время на тему, из-за чего время исполнения нужно считать со сдвигом)

Потенциальные решения:

- перебор
- эволюционный алгоритм

Было проработано решение с использованием эволюционного алгоритма, но появились вопросы, такие как:

1. Что считать хромосомой? Распределение задач на всех или одного исполнителя?
2. Как производить мутацию и скрещивание хромосом? Совместимы ли будут отдельные пути и как правильно их валидировать?
3. Как считать фитнес-функцию -- основываясь на данных из БД1?
4. Действительно ли нужны предшествующие оптимизации для реализации этого варианта (возможно, отдельный эволюционный алгоритм и есть решение этой проблемы)

## Возможные улучшения

Сейчас коэффициент оперативности применяется только для выбора исполнителя на тему, но при этом он не влияет на время исполнения. Можно попробовать улучшить функцию расчета времени и добавить формулу
<!-- gitflic doesnt support latex embeddings in md
$$ t_{\text{факт}} = \left(1 - \frac{1}{NM} \cdot V_{ij}\right) \cdot t_{\text{план}} $$ -->
<!-- gitflic doesnt support svg embeddings either -->
![duration_formula.svg](/docs/duration_formula.svg)
*формула математически не доказана

- t_факт - фактическое время исполнения задачи отдельным исполнителем
- N - кол-во исполнителей
- M - кол-во тем
- Vij - коэффициент оперативности i-исполнителя j-темы
- t_plan - изначальное время исполнения задачи

## HowTo

Запустить первые 2 оптимизации

```shell
python $HOME/compliance-audit/src/chain_algo/chain.py
```

Запустить эволюционный алгоритм

```shell
python $HOME/compliance-audit/src/chain_algo/evolution.py
```
